"""
era_validator.py - Модуль для проверки соответствия контента эпохе древнего мира.
Валидирует сообщения игроков и их команды на историческую достоверность.
"""

from typing import Tuple, Optional, List, Dict
import re
from datetime import datetime

from utils import logger, log_function_call
from ..model_interface import model
from ..prompt_templates import get_check_era_prompt


class EraValidator:
    """
    Класс для проверки соответствия сообщений и команд эпохе древнего мира.
    Использует комбинацию эвристических правил и запросов к LLM.
    """

    # Список терминов и технологий, которые не соответствуют древнему миру
    ANACHRONISTIC_TERMS = [
        # Современные технологии
        r"автомобил", r"машин[аы]", r"поезд", r"электричеств", r"телефон", r"компьютер",
        r"интернет", r"телевизор", r"радио", r"самолет", r"вертолет", r"ракет",
        r"атомн", r"ядерн", r"пластик", r"пластмасс", r"синтетич", r"робот",

        # Современное оружие
        r"автомат", r"пистолет", r"винтовк", r"пулемет", r"миномет", r"танк",
        r"бомб[аы]", r"гранат", r"снаряд", r"торпед", r"ракетн", r"нарезн",

        # Современные материалы и химия
        r"пластик", r"нейлон", r"синтетик", r"алюмини", r"резин", r"асфальт",
        r"бетон", r"цемент", r"уран", r"плутони",

        # Современные концепции и институты
        r"демократи", r"конституци", r"парламент", r"президент", r"премьер",
        r"выбор[ыов]", r"референдум", r"голосовани", r"банк", r"инфляци", r"капитализм",

        # Современные транспортные средства
        r"автобус", r"метро", r"трамвай", r"троллейбус", r"такси", r"аэропорт",
        r"автострад", r"шоссе",

        # Современные средства связи
        r"телеграф", r"телефон", r"радио", r"телевидени", r"интернет", r"спутник",
        r"компьютер", r"ноутбук", r"сотов", r"мобильн", r"смартфон",

        # Географические термины, открытые позже
        r"америк", r"австрали", r"сша", r"канад", r"аргентин", r"бразили",

        # Современная медицина
        r"антибиотик", r"вакцин", r"прививк", r"рентген", r"томограф", r"мрт",
        r"операци", r"хирург", r"анестез", r"наркоз", r"больниц", r"скорая помощь"
    ]

    # Список терминов, всегда допустимых в древнем мире
    ALLOWED_TERMS = [
        # Общие исторические термины
        r"царь", r"фараон", r"император", r"жрец", r"храм", r"дворец", r"крепость",
        r"город", r"деревн", r"поселени", r"рабы", r"воин", r"армия", r"флот", r"земля",

        # Древние технологии
        r"колесниц", r"лук", r"меч", r"копье", r"щит", r"таран", r"осадн", r"катапульт",
        r"баллист", r"кораб", r"лодк", r"галер", r"триер", r"канал", r"акведук", r"мост",

        # Древние материалы
        r"камен", r"дерев", r"глин", r"бронз", r"медь", r"железо", r"золот", r"серебр",
        r"олово", r"кожа", r"шерст", r"лен", r"папирус",

        # Древнее сельское хозяйство
        r"пшениц", r"ячмен", r"рис", r"оливк", r"вин", r"сад", r"огород", r"поле",
        r"зерно", r"плуг", r"мотыг", r"ирригаци", r"скот", r"овц", r"коз", r"коров",

        # Древние строения
        r"пирамид", r"зиккурат", r"стен", r"башн", r"дом", r"дворец", r"храм", r"святилищ",
        r"гробниц", r"амфитеатр", r"арен", r"ипподром", r"форум", r"агор", r"колонн",

        # Древние религиозные практики
        r"жертвоприношени", r"молитв", r"ритуал", r"церемони", r"бог", r"богин",
        r"божеств", r"оракул", r"предсказани", r"пророк", r"жрец", r"жриц", r"священник",

        # Разрешенные современные термины с историческими аналогами
        r"налог", r"дань", r"торговл", r"рынок", r"порт", r"посол", r"дипломат",
        r"договор", r"соглашени", r"союз", r"закон"
    ]

    @staticmethod
    @log_function_call
    def quick_validate(text: str) -> Tuple[bool, Optional[str]]:
        """
        Быстрая валидация текста на основе списков ключевых слов.

        Args:
            text: Текст для проверки

        Returns:
            Tuple[bool, Optional[str]]: (соответствует ли эпохе, причина несоответствия)
        """
        text_lower = text.lower()

        # Проверяем на запрещенные термины
        for term in EraValidator.ANACHRONISTIC_TERMS:
            match = re.search(term, text_lower)
            if match:
                term_found = match.group(0)
                return False, f"Обнаружен анахронизм: '{term_found}'. Это не соответствует эпохе древнего мира."

        # Если нет запрещенных терминов, проверяем на наличие хотя бы одного разрешенного
        has_allowed_term = False
        for term in EraValidator.ALLOWED_TERMS:
            if re.search(term, text_lower):
                has_allowed_term = True
                break

        # Если сообщение слишком короткое, считаем его допустимым
        if len(text) < 20:
            return True, None

        # Если нет ни одного разрешенного термина, это подозрительно
        if not has_allowed_term:
            return None, "Не удалось определить соответствие эпохе на основе ключевых слов."

        return True, None

    @staticmethod
    @log_function_call
    def deep_validate(text: str) -> Tuple[bool, str]:
        """
        Глубокая валидация текста с помощью LLM.

        Args:
            text: Текст для проверки

        Returns:
            Tuple[bool, str]: (соответствует ли эпохе, комментарий)
        """
        # Формируем запрос к модели
        prompt = get_check_era_prompt(text)

        # Получаем ответ от модели
        response = model.generate_response(prompt, max_tokens=300, temperature=0.3)

        # Парсим ответ
        is_compatible = False
        comment = "Не удалось определить соответствие эпохе"

        # Ищем ответ о соответствии
        compatible_match = re.search(r"СООТВЕТСТВУЕТ:\s*(.+?)(?=\n|$)", response, re.IGNORECASE)
        if compatible_match:
            answer = compatible_match.group(1).strip().lower()
            is_compatible = answer in ["да", "yes", "true", "соответствует"]

        # Ищем комментарий
        comment_match = re.search(r"КОММЕНТАРИЙ:\s*(.+?)(?=\n\n|$)", response, re.DOTALL | re.IGNORECASE)
        if comment_match:
            comment = comment_match.group(1).strip()

        return is_compatible, comment

    @staticmethod
    @log_function_call
    def validate(text: str, use_llm: bool = True) -> Tuple[bool, str]:
        """
        Валидирует текст на соответствие эпохе древнего мира.
        Сначала выполняет быструю проверку, затем при необходимости глубокую.

        Args:
            text: Текст для проверки
            use_llm: Использовать ли LLM для глубокой проверки

        Returns:
            Tuple[bool, str]: (соответствует ли эпохе, комментарий)
        """
        # Сначала выполняем быструю проверку
        quick_result, quick_comment = EraValidator.quick_validate(text)

        # Если быстрая проверка дала однозначный результат, возвращаем его
        if quick_result is not None:
            return quick_result, quick_comment or "Проверка на основе ключевых слов"

        # Если требуется глубокая проверка и разрешено использование LLM
        if use_llm:
            return EraValidator.deep_validate(text)

        # По умолчанию разрешаем сообщение, если не можем точно определить
        return True, "Не удалось определить соответствие эпохе, сообщение разрешено по умолчанию"

    @staticmethod
    @log_function_call
    def get_era_years() -> Tuple[int, int]:
        """
        Возвращает временные границы эпохи древнего мира.

        Returns:
            Tuple[int, int]: (начальный год, конечный год)
        """
        return -3000, 500  # Примерные границы древнего мира (3000 до н.э. - 500 н.э.)

    @staticmethod
    @log_function_call
    def suggest_era_appropriate_alternative(text: str) -> Optional[str]:
        """
        Предлагает альтернативу для текста, не соответствующего эпохе.

        Args:
            text: Исходный текст

        Returns:
            Optional[str]: Альтернативный текст или None, если не удалось создать
        """
        prompt = f"""Ты - исторический консультант игры, действие которой происходит в древнем мире.
        
Игрок отправил сообщение, которое не соответствует эпохе древнего мира:
"{text}"

Предложи альтернативную формулировку, которая выражает ту же идею, но использует термины и понятия, 
соответствующие древнему миру (примерно 3000 г. до н.э. - 500 г. н.э.).

Ответь только альтернативной формулировкой без дополнительных пояснений."""

        try:
            response = model.generate_response(prompt, max_tokens=300, temperature=0.7)
            return response.strip()
        except Exception as e:
            logger.error(f"Ошибка при создании альтернативной формулировки: {e}")
            return None


# Создаем экземпляр валидатора для удобного доступа
validator = EraValidator()


def is_era_compatible(text: str, use_llm: bool = True) -> Tuple[bool, str]:
    """
    Проверяет, соответствует ли текст эпохе древнего мира.

    Args:
        text: Текст для проверки
        use_llm: Использовать ли LLM для глубокой проверки

    Returns:
        Tuple[bool, str]: (соответствует ли эпохе, комментарий)
    """
    return validator.validate(text, use_llm)


def suggest_alternative(text: str) -> Optional[str]:
    """
    Предлагает альтернативу для текста, не соответствующего эпохе.

    Args:
        text: Исходный текст

    Returns:
        Optional[str]: Альтернативный текст или None
    """
    return validator.suggest_era_appropriate_alternative(text)
